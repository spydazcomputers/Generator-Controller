esphome:
  name: generatorcontroller
  friendly_name: GeneratorController

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "qza8GSkOARmrbuwb8z2xGww6dXice/YJIoDkaeK0WWw="

ota:
  - platform: esphome
    password: "aa11f24d588137b900808fb4eb94c25e"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Generatorcontroller"
    password: "oQfxQ5doNjPo"

# i2c scanner for accelerometer
# i2c:
#   sda: GPIO21
#   scl: GPIO22
#   scan: true

binary_sensor:
  - platform: gpio
    pin: 21
    id: generator_running
    name: "Generator Running"
    device_class: running
  
  - platform: template
    name: "Generator Start Fault"
    id: generator_start_fault
    device_class: problem
    publish_initial_state: True
        

switch:
  - platform: gpio
    pin: 17
    id: choke_relay
    name: "Choke Relay"
    restore_mode: ALWAYS_OFF

  - platform: gpio
    pin: 18
    id: starter_relay
    name: "Starter Relay"
    restore_mode: ALWAYS_OFF

  - platform: gpio
    pin: 22
    id: output_relay
    name: "Output Relay"
    restore_mode: ALWAYS_OFF

  - platform: gpio
    pin: 23
    id: kill_switch
    name: "Kill Switch"
    restore_mode: ALWAYS_OFF

number:
  - platform: template
    name: "Starter Time"
    id: starter_time
    min_value: 1
    max_value: 10
    step: 1
    unit_of_measurement: "s"
    optimistic: True
    restore_value: true
    initial_value: 2

  - platform: template
    name: "Choke Delay"
    id: choke_delay
    min_value: 0.5
    max_value: 5
    step: 0.5
    unit_of_measurement: "s"
    optimistic: True
    restore_value: true
    initial_value: 1

  - platform: template
    name: "Kill Delay"
    id: kill_delay
    min_value: 0.1
    max_value: 2
    step: 0.1
    unit_of_measurement: "s"
    optimistic: True
    restore_value: true
    initial_value: 0.5

button:
  - platform: template
    name: "Start Generator"
    id: start_generator
    on_press:
      if:      
        condition:
          any:
           - binary_sensor.is_on: generator_running
           - binary_sensor.is_on: generator_start_fault  
        then:
          - logger.log: "Generator cannot start"
          - logger.log: "Generator Running"
          - logger.log: id(generator_running).state
          - logger.log: "Generator Faulted"
          - logger.log: id(generator_start_fault).state
        else:
          - logger.log: "Starting generator"
      
          #ensure output relay is off
          - switch.turn_off: output_relay
          #ensure starter and choke relays are off
          - switch.turn_off: starter_relay
          - switch.turn_off: choke_relay
          #ensure kill switch is off
          - switch.turn_off: kill_switch
          #activate choke and starter relays
          - switch.turn_on: choke_relay
          - switch.turn_on: starter_relay
          #
          - delay: !lambda 'return id(starter_time).state * 1000;'
          - switch.turn_off: starter_relay
          #wait for generator running then turn off the choke 
          - wait_until:
              condition:
                  binary_sensor.is_on: generator_running
              timeout: 15s
          - if:
              condition:
                binary_sensor.is_on: generator_running
              then:
                - delay: !lambda 'return id(choke_delay).state * 1000;'
                - switch.turn_off: choke_relay
                - delay: 2s
                - switch.turn_on: output_relay
              else:
                - switch.turn_on: kill_switch
                - logger.log: "Start Failed"
                - lambda: id(generator_start_fault).publish_state(true);
              
               
        

  - platform: template
    name: "Stop Generator"
    id: stop_generator
    on_press:
      - switch.turn_off: output_relay
      - delay: !lambda 'return id(kill_delay).state * 1000;'
      - switch.turn_on: kill_switch
      - delay: !lambda 'return id(kill_delay).state * 1000;'
      - switch.turn_off: kill_switch

  #Resets all faults and Relays to startup
  - platform: template
    name: "Reset"
    id: reset_button
    on_press:
      - lambda: id(generator_start_fault).publish_state(false);
      - switch.turn_off: starter_relay
      - switch.turn_off: output_relay
      - switch.turn_off: choke_relay
      - switch.turn_off: kill_switch

          



# sensor:
#   - platform: mpu6050
#     accel_x:
#       id: accel_x
#     accel_y:
#       id: accel_y
#     accel_z:
#       id: accel_z
#     update_interval: 50ms # Fast updates to catch quick vibrations
#     address: 0x68

#   # Template sensor to calculate the magnitude of the acceleration vector
#   - platform: template
#     name: "Acceleration Magnitude"
#     id: accel_magnitude
#     unit_of_measurement: 'm/sÂ²'
#     lambda: |-
#       return sqrt(pow(id(accel_x).state, 2) + pow(id(accel_y).state, 2) + pow(id(accel_z).state, 2));
#     filters:
#       # Use a median filter to remove random spikes
#       - median:
#           window_size: 5
#           send_every: 3
#           send_first_at: 1
#       # Only publish significant changes to avoid constant state updates
#       - threshold: 0.5
#   - platform: analog_threshold  
#     name: "Abnormal Vibration Detected"
#     sensor_id: accel_magnitude
#     threshold: 12.0 # Set a value higher than normal operation
#     filters:
#       # Prevent false triggers from a single spike
#       - delayed_on: 1s
#       # Ensure the alert persists for a minimum duration
#       - delayed_off: 5s
      
captive_portal:

web_server:
  
    