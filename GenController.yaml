esphome:
  name: generatorcontroller
  friendly_name: GeneratorController

esp32:
  board: esp32-c6-devkitc-1
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "qza8GSkOARmrbuwb8z2xGww6dXice/YJIoDkaeK0WWw="

ota:
  - platform: esphome
    password: "aa11f24d588137b900808fb4eb94c25e"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Generatorcontroller"
    password: "oQfxQ5doNjPo"


# Analog input for sensing generator running light level. 
# This is then used to determine if the generator is running or not.
# Publishes to the binary sensor "Generator Running" when above the set level.
# The level can be adjusted in Home Assistant via the "Running Light Level" number entity.
# Clears the binary sensor when the light level drops below the set level minus a small hysteresis.

sensor:
  - platform: adc
    pin: 3
    id: generator_light_level
    attenuation: auto
    name: "Generator Output LED"
    on_value_range:
      - above: !lambda 'return id(light_level_switch).state;'
        then: 
          - lambda: id(generator_running).publish_state(true);
      - below: !lambda 'return id(light_level_switch).state - .2;'
        then:
          - lambda: id(generator_running).publish_state(false);
    update_interval: 1000ms
    web_server:
      sorting_group_id: sorting_group_status


binary_sensor:
  # sensor to indicate if the generator is running
  - platform: template
    id: generator_running
    name: "Generator Running"
    device_class: running
    web_server:
      sorting_group_id: sorting_group_status
  
  # sensor to indicate a fault in starting the generator
  - platform: template
    name: "Generator Start Fault"
    id: generator_start_fault
    device_class: problem
    publish_initial_state: True
    web_server:
      sorting_group_id: sorting_group_status

  # GPIO buttons to receive RF remote commands via a 433MHz receiver module
  # These buttons simulate the pressing of physical buttons connected to the ESP32
  # Each button press triggers the corresponding action via the button components defined below
  - platform: gpio
    pin: 
      number: 4
      mode: 
        input: true
        pullup: True
    id: RF_GenStart
    name: "RF Gen Start Command"
    device_class: running
    on_release: 
      then:
        - button.press: start_generator
    web_server:
      sorting_group_id: sorting_group_status

  - platform: gpio
    pin: 
      number: 5
      mode: 
        input: true
        pullup: True
    id: RF_GenStop
    name: "RF Gen Stop Command"
    device_class: running 
    on_release: 
      then:
        - button.press: stop_generator 
    web_server:
      sorting_group_id: sorting_group_status    

  - platform: gpio
    pin: 
      number: 8
      mode: 
        input: true
        pullup: True
    name: "RF Reset"
    device_class: power
    on_release: 
      then:
        - button.press: remote_restart
    web_server:
      sorting_group_id: sorting_group_status
  
  
   
        

switch:
  # Choke relay enables the choke on the generator
  - platform: gpio
    pin: 10
    id: choke_relay
    name: "Choke Relay"
    restore_mode: ALWAYS_OFF
    web_server:
      sorting_group_id: sorting_group_manual

  # Starter relay engages the starter motor on the generator
  - platform: gpio
    pin: 11
    id: starter_relay
    name: "Starter Relay"
    restore_mode: ALWAYS_OFF
    web_server:
      sorting_group_id: sorting_group_manual

  # Output relay enables the output from the generator to the load
  - platform: gpio
    pin: 22
    id: output_relay
    name: "Output Relay"
    restore_mode: ALWAYS_OFF
    web_server:
      sorting_group_id: sorting_group_manual

  # Kill switch relay grounds the ignition system to stop the generator 
  - platform: gpio
    pin: 23
    id: kill_switch
    name: "Kill Switch"
    restore_mode: ALWAYS_OFF
    web_server:
      sorting_group_id: sorting_group_manual

number:
  # Start time is how long to engage the starter motor
  - platform: template
    name: "Starter Time"
    id: starter_time
    min_value: 1
    max_value: 15
    step: 1
    unit_of_measurement: "s"
    optimistic: True
    restore_value: true
    initial_value: 2
    web_server:
      sorting_group_id: sorting_group_number_settings

  # Choke delay is how long to wait after the generator is running before turning off the choke
  - platform: template
    name: "Choke Delay"
    id: choke_delay
    min_value: 0.5
    max_value: 30
    step: 1
    unit_of_measurement: "s"
    optimistic: True
    restore_value: true
    initial_value: 5
    web_server:
      sorting_group_id: sorting_group_number_settings
  # Kill delay is how long to hold the kill switch on when stopping the generator
  - platform: template
    name: "Kill Delay"
    id: kill_delay
    min_value: 5
    max_value: 30
    step: 1
    unit_of_measurement: "s"
    optimistic: True
    restore_value: true
    initial_value: 5
    web_server:
      sorting_group_id: sorting_group_number_settings
  # Light level switch is the voltage level at which the generator running light is considered on
  - platform: template
    name: "Running Light Level"
    id: light_level_switch
    min_value: 0
    max_value: 3.0
    step: .01
    unit_of_measurement: "V"
    optimistic: true
    restore_value: true
    initial_value: 1.5
    web_server:
      sorting_group_id: sorting_group_number_settings

button:
  #Restart button to restart the ESP32 activated via RF remote or web interface
  - platform: restart
    id: remote_restart
    name: "Restart"
    web_server:
      sorting_group_id: sorting_group_switches

  #Button to start the generator
  #This button is activated via RF remote or web interface
  #The logic ensures the generator is not already running or faulted before attempting to start
  #If the generator fails to start within the timeout period, it activates the kill switch and sets a fault state
  #If the generator starts successfully, it turns off the choke after a delay and then enables the output relay
  - platform: template
    name: "Start Generator"
    id: start_generator
    web_server:
      sorting_group_id: sorting_group_switches
    on_press:
      if:      
        condition:
          any:
           - binary_sensor.is_on: generator_running
           - binary_sensor.is_on: generator_start_fault  
        then:
          - logger.log: "Generator cannot start"
          - logger.log: "Generator Running"
          - logger.log: id(generator_running).state
          - logger.log: "Generator Faulted"
          - logger.log: id(generator_start_fault).state
        else:
          - logger.log: "Starting generator"
      
          #ensure output relay is off
          - switch.turn_off: output_relay
          #ensure starter and choke relays are off
          - switch.turn_off: starter_relay
          - switch.turn_off: choke_relay
          #ensure kill switch is off
          - switch.turn_off: kill_switch
          #activate choke and starter relays
          - switch.turn_on: choke_relay
          - switch.turn_on: starter_relay
          #
          - delay: !lambda 'return id(starter_time).state * 1000;'
          - switch.turn_off: starter_relay
          #wait for generator running then turn off the choke 
          - wait_until:
              condition:
                  binary_sensor.is_on: generator_running
              timeout: 15s
          - if:
              condition:
                binary_sensor.is_on: generator_running
              then:
                - delay: !lambda 'return id(choke_delay).state * 1000;'
                - switch.turn_off: choke_relay
                - delay: 2s
                - switch.turn_on: output_relay
              else:
                - switch.turn_on: kill_switch
                - logger.log: "Start Failed"
                - lambda: id(generator_start_fault).publish_state(true);
                - switch.turn_off: choke_relay
                - delay: !lambda 'return id(kill_delay).state * 1000;'
                - switch.turn_off: kill_switch
              
               
        
  #Button to stop the generator
  #This button is activated via RF remote or web interface
  #The logic DOES NOT CHECK IF the generator is running before attempting to stop
  #It turns off the output relay, then activates the kill switch for a set delay to stop the generator
  #Finally, it ensures the choke and starter relays are off
  #This ensures the generator is fully stopped regardless of its initial state

  - platform: template
    name: "Stop Generator"
    id: stop_generator
    web_server:
      sorting_group_id: sorting_group_switches
    on_press:
      - switch.turn_off: output_relay
      - delay: !lambda 'return id(kill_delay).state * 1000;'
      - switch.turn_on: kill_switch
      - delay: !lambda 'return id(kill_delay).state * 1000;'
      - switch.turn_off: kill_switch
      - switch.turn_off: choke_relay
      - switch.turn_off: starter_relay

  #Resets all faults and Relays to startup
  #Activated onboot, local reset button or via web interface
  - platform: template
    name: "Reset"
    id: reset_button
    web_server:
      sorting_group_id: sorting_group_switches
    on_press:
      - lambda: id(generator_start_fault).publish_state(false);
      - switch.turn_off: starter_relay
      - switch.turn_off: output_relay
      - switch.turn_off: choke_relay
      - switch.turn_off: kill_switch

          


      
captive_portal:

web_server:
  version: 3
  sorting_groups:
  - id: sorting_group_status
    name: "Status"
    sorting_weight: 10
  - id: sorting_group_switches
    name: "Buttons"
    sorting_weight: 20    
  - id: sorting_group_number_settings
    name: "Number settings"
    sorting_weight: 30
  - id: sorting_group_manual
    name: "Manual Relay Control"
    sorting_weight: 40  
  
    